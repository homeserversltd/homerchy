#!/bin/bash

# Set log file path early (before helpers load, in case they fail)
export OMARCHY_INSTALL_LOG_FILE="${OMARCHY_INSTALL_LOG_FILE:-/var/log/omarchy-install.log}"

# Debug logging helper - only logs if OMARCHY_DEBUG is set
debug_log() {
  if [[ -n "${OMARCHY_DEBUG:-}" ]]; then
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] configurator: $*" >> "$OMARCHY_INSTALL_LOG_FILE" 2>&1
  fi
}

# Always log errors and important events
log() {
  echo "[$(date '+%Y-%m-%d %H:%M:%S')] configurator: $*" >> "$OMARCHY_INSTALL_LOG_FILE" 2>&1
}

# Log that configurator started
log "Script started"
debug_log "OMARCHY_PATH=${OMARCHY_PATH:-not set}"
debug_log "OMARCHY_INSTALL=${OMARCHY_INSTALL:-not set}"
debug_log "OMARCHY_VM_TEST=${OMARCHY_VM_TEST:-not set}"
debug_log "OMARCHY_DEBUG=${OMARCHY_DEBUG:-not set}"

# Rely on Omarchy for styling and error handling
if [[ -n "${OMARCHY_DEBUG:-}" ]]; then
  source "$OMARCHY_INSTALL/helpers/all.sh" >> "$OMARCHY_INSTALL_LOG_FILE" 2>&1 || {
    log "ERROR: Failed to load helpers"
    exit 1
  }
else
  source "$OMARCHY_INSTALL/helpers/all.sh" || {
    log "ERROR: Failed to load helpers"
    exit 1
  }
fi

# Ensure tzupdate is available for guessing timezone (optional, AUR package)
# Note: tzupdate is in AUR (as 'tz'), not official repos, so it won't be available during ISO boot
# The timezone selection code already handles its absence gracefully
if ! command -v tzupdate >/dev/null; then
  # Silently skip - timezone selection will work without it
  debug_log "tzupdate not available (AUR package), timezone guessing will be skipped"
fi

abort() {
  gum style "${1:-Aborted installation}"
  echo
  gum style "You can retry later by running: python3 ./.automated_script.py"
  exit 1
}

step() {
  # Only clear logo on first step to reduce flashing
  if [[ -z "${STEP_COUNT:-}" ]]; then
    clear_logo
    export STEP_COUNT=1
  fi
  echo
  gum style "$1"
  echo
}

notice() {
  # Don't clear logo for notices to reduce flashing
  echo
  gum spin --spinner "pulse" --title "$1" -- sleep "${2:-2}"
  echo
}

# Load VM test settings from JSON file
load_vm_settings() {
  local settings_file="/root/vmtools/settings.json"
  if [[ -n "${OMARCHY_VM_TEST:-}" && -f "$settings_file" ]]; then
    debug_log "load_vm_settings: Loading from $settings_file"
    # Use jq to extract values, with fallbacks to defaults if file is malformed
    VM_KEYBOARD_CHOICE=$(jq -r '.keyboard.choice // "English (US)"' "$settings_file" 2>/dev/null || echo "English (US)")
    VM_KEYBOARD_CODE=$(jq -r '.keyboard.code // "us"' "$settings_file" 2>/dev/null || echo "us")
    VM_USERNAME=$(jq -r '.user.username // "testuser"' "$settings_file" 2>/dev/null || echo "testuser")
    VM_PASSWORD=$(jq -r '.user.password // "testpass123"' "$settings_file" 2>/dev/null || echo "testpass123")
    VM_FULL_NAME=$(jq -r '.user.full_name // "Test User"' "$settings_file" 2>/dev/null || echo "Test User")
    VM_EMAIL=$(jq -r '.user.email_address // "test@example.com"' "$settings_file" 2>/dev/null || echo "test@example.com")
    VM_HOSTNAME=$(jq -r '.system.hostname // "homerchy"' "$settings_file" 2>/dev/null || echo "homerchy")
    VM_TIMEZONE=$(jq -r '.system.timezone // "America/New_York"' "$settings_file" 2>/dev/null || echo "America/New_York")
    debug_log "load_vm_settings: Loaded settings successfully"
    return 0
  else
    debug_log "load_vm_settings: VM test mode not enabled or settings file not found"
    return 1
  fi
}

# STEP 1: KEYBOARD LAYOUT

keyboard_form() {
  debug_log "keyboard_form: Starting"
  step "Let's setup your machine..."
  keyboards=$'Azerbaijani|azerty
Belarusian|by
Belgian|be-latin1
Bosnian|ba
Bulgarian|bg-cp1251
Croatian|croat
Czech|cz
Danish|dk-latin1
Dutch|nl
English (UK)|uk
English (US)|us
English (US, Dvorak)|dvorak
Estonian|et
Finnish|fi
French|fr
French (Canada)|cf
French (Switzerland)|fr_CH
Georgian|ge
German|de
German (Switzerland)|de_CH-latin1
Greek|gr
Hebrew|il
Hungarian|hu
Icelandic|is-latin1
Irish|ie
Italian|it
Japanese|jp106
Kazakh|kazakh
Khmer (Cambodia)|khmer
Kyrgyz|kyrgyz
Lao|la-latin1
Latvian|lv
Lithuanian|lt
Macedonian|mk-utf
Norwegian|no-latin1
Polish|pl
Portuguese|pt-latin1
Portuguese (Brazil)|br-abnt2
Romanian|ro
Russian|ru
Serbian|sr-latin
Slovak|sk-qwertz
Slovenian|slovene
Spanish|es
Spanish (Latin American)|la-latin1
Swedish|sv-latin1
Tajik|tj_alt-UTF8
Turkish|trq
Ukrainian|ua'
  
  # Non-interactive mode for VM testing
  if [[ -n "${OMARCHY_VM_TEST:-}" ]]; then
    if load_vm_settings; then
      choice="$VM_KEYBOARD_CHOICE"
      keyboard="$VM_KEYBOARD_CODE"
      debug_log "keyboard_form: VM Test Mode - using settings from /root/vmtools/settings.json"
      echo "VM Test Mode: Using keyboard layout from settings ($choice)"
    else
      # Fallback to defaults if settings file not found
      choice="English (US)"
      keyboard="us"
      debug_log "keyboard_form: VM Test Mode - using fallback defaults (English US)"
      echo "VM Test Mode: Using default keyboard layout (English US)"
    fi
  else
    choice=$(printf '%s\n' "$keyboards" | cut -d'|' -f1 | gum choose --height 10 --selected "English (US)" --header "Select keyboard layout") || abort
    keyboard=$(printf '%s\n' "$keyboards" | awk -F'|' -v c="$choice" '$1==c{print $2; exit}')
    debug_log "keyboard_form: Selected $choice ($keyboard)"
  fi

  # Only attempt to load keyboard layout if we're on a real console
  # loadkeys only works on Linux virtual consoles (tty), not in terminal emulators
  if [[ $(tty 2>/dev/null) == "/dev/tty"* ]]; then
    loadkeys "$keyboard" 2>/dev/null && debug_log "keyboard_form: Loaded keyboard layout"
  fi
  debug_log "keyboard_form: Completed"
}

keyboard_form

# STEP 2: USER

user_form() {
  debug_log "user_form: Starting"
  step "Let's setup your user account..."

  # Non-interactive mode for VM testing
  if [[ -n "${OMARCHY_VM_TEST:-}" ]]; then
    if load_vm_settings; then
      username="$VM_USERNAME"
      password="$VM_PASSWORD"
      password_confirmation="$VM_PASSWORD"
      full_name="$VM_FULL_NAME"
      email_address="$VM_EMAIL"
      hostname="$VM_HOSTNAME"
      timezone="$VM_TIMEZONE"
      debug_log "user_form: VM Test Mode - using settings from /root/vmtools/settings.json"
      debug_log "user_form: Username=$username, Hostname=$hostname, Timezone=$timezone"
      echo "VM Test Mode: Using values from settings"
      echo "  Username: $username"
      echo "  Hostname: $hostname"
      echo "  Timezone: $timezone"
    else
      # Fallback to defaults if settings file not found
      username="testuser"
      password="testpass123"
      password_confirmation="testpass123"
      full_name="Test User"
      email_address="test@example.com"
      hostname="homerchy"
      timezone="America/New_York"
      debug_log "user_form: VM Test Mode - using fallback defaults"
      debug_log "user_form: Username=$username, Hostname=$hostname, Timezone=$timezone"
      echo "VM Test Mode: Using default values"
      echo "  Username: $username"
      echo "  Hostname: $hostname"
      echo "  Timezone: $timezone"
    fi
  else
    while true; do
      username=$(gum input --placeholder "Alphanumeric without spaces (like dhh)" --prompt.foreground="#845DF9" --prompt "Username> ") || abort

      if [[ "$username" =~ ^[a-z_][a-z0-9_-]*[$]?$ ]]; then
        break
      else
        notice "Username must be alphanumeric with no spaces" 1
      fi
    done

    while true; do
      password=$(gum input --placeholder "Used for user + root + encryption" --prompt.foreground="#845DF9" --password --prompt "Password> ") || abort
      password_confirmation=$(gum input --placeholder "Must match the password you just typed" --prompt.foreground="#845DF9" --password --prompt "Confirm> ") || abort

      if [[ -n "$password" && "$password" == "$password_confirmation" ]]; then
        break
      elif [[ -z "$password" ]]; then
        notice "Your password can't be blank!" 1
      else
        notice "Passwords didn't match!" 1
      fi
    done

    full_name=$(gum input --placeholder "Used for git authentication (hit return to skip)" --prompt.foreground="#845DF9" --prompt "Full name> ")
    email_address=$(gum input --placeholder "Used for git authentication (hit return to skip)" --prompt.foreground="#845DF9" --prompt "Email address> ")

    while true; do
      hostname=$(gum input --placeholder "Alphanumeric without spaces (or return for 'homerchy')" --prompt.foreground="#845DF9" --prompt "Hostname> ")

      if [[ "$hostname" =~ ^[A-Za-z_][A-Za-z0-9_-]*\$?$ ]]; then
        break
      elif [[ -z $hostname ]]; then
        hostname="homerchy"
        break
      else
        notice "Hostname must be alphanumeric using dashes or underscores but no spaces" 1
      fi
    done

    # Pick timezone
    geo_guessed_timezone=$(tzupdate -p 2>/dev/null)

    if [[ -n $geo_guessed_timezone ]]; then
      timezone=$(timedatectl list-timezones | gum choose --height 10 --selected "$geo_guessed_timezone" --header "Timezone") || abort
    else
      timezone=$(timedatectl list-timezones | gum filter --height 10 --header "Timezone") || abort
    fi
  fi

  # Hash the password using yescrypt
  password_hash=$(printf '%s' "$password" | openssl passwd -6 -stdin)
  debug_log "user_form: Completed"
}

user_form

# Skip confirmation in VM test mode
if [[ -z "${OMARCHY_VM_TEST:-}" ]]; then
  while true; do
    # Add manual padding since gum table -p doesn't respect padding
    echo -e "Field,Value
Username,$username
Password,$(printf "%${#password}s" | tr ' ' '*')
Full name,${full_name:-[Skipped]}
Email address,${email_address:-[Skipped]}
Hostname,$hostname
Timezone,$timezone
Keyboard,$keyboard" |
      gum table -s "," -p | sed "s/^/${PADDING_LEFT_SPACES}/"

    echo
    if gum confirm --negative "No, change it" "Does this look right?"; then
      break
    else
      keyboard_form
      user_form
    fi
  done
fi

# STEP 3: DISK

get_disk_info() {
  local device="$1"
  local size model

  # Get basic disk information
  size=$(lsblk -dno SIZE "$device" 2>/dev/null)
  model=$(lsblk -dno MODEL "$device" 2>/dev/null | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')

  # Format display string
  local display="$device"
  [[ -n "$size" ]] && display="$display ($size)"
  [[ -n "$model" ]] && display="$display - $model"

  echo "$display"
}

disk_form() {
  echo "[$(date '+%Y-%m-%d %H:%M:%S')] configurator: disk_form: Starting" >> "$OMARCHY_INSTALL_LOG_FILE" 2>&1
  step "Let's select where to install Homerchy..."

  # Don't offer the install media as an option (Arch ISO mounts it here)
  local exclude_disk
  exclude_disk=$(findmnt -no SOURCE /run/archiso/bootmnt 2>/dev/null || true)
  debug_log "disk_form: Excluding boot disk: ${exclude_disk:-none}"

  # List all installable disks, excluding the boot device if present
  local available_disks
  available_disks=$(
    lsblk -dpno NAME,TYPE |
      awk '$2=="disk"{print $1}' |
      grep -E '/dev/(sd|hd|vd|nvme|mmcblk|xv)' |
      { if [[ -n "$exclude_disk" ]]; then grep -Fvx "$exclude_disk"; else cat; fi; }
  )
  debug_log "disk_form: Available disks: $(echo "$available_disks" | tr '\n' ' ')"

  # Non-interactive mode for VM testing - use first available disk
  if [[ -n "${OMARCHY_VM_TEST:-}" ]]; then
    disk=$(echo "$available_disks" | head -n1)
    if [[ -z "$disk" ]]; then
      log "disk_form: ERROR: No disk found!"
      echo "Error: No disk found for installation"
      exit 1
    fi
    debug_log "disk_form: VM Test Mode - selected disk: $disk"
    echo "VM Test Mode: Using disk $disk"
  else
    # Get available disks and format them with info
    local disk_options=""
    while IFS= read -r device; do
      if [[ -n "$device" ]]; then
        disk_info=$(get_disk_info "$device")
        disk_options="$disk_options$disk_info"$'\n'
      fi
    done <<<"$available_disks"

    selected_display=$(echo "$disk_options" | gum choose --header "Select install disk") || abort
    disk=$(echo "$selected_display" | awk '{print $1}')
    debug_log "disk_form: Selected disk: $disk"
  fi
  debug_log "disk_form: Completed"
}

disk_form

# Skip confirmation in VM test mode
if [[ -z "${OMARCHY_VM_TEST:-}" ]]; then
  while true; do
    gum style "Everything will be overwritten. There is no recovery possible."

    echo
    if gum confirm --affirmative "Yes, format disk" --negative "No, change it" "Confirm overwriting ${disk}"; then
      break
    else
      disk_form
    fi
  done
fi

clear

debug_log "Saving user configuration files"

# Save user full name and email address, so the autostart can
# set them as OMARCHY_USER_NAME and OMARCHY_USER_EMAIL
echo "$full_name" >user_full_name.txt
echo "$email_address" >user_email_address.txt
debug_log "Created user_full_name.txt and user_email_address.txt"

# Escape username and password for safe inclusion
password_escaped=$(echo -n "$password" | jq -Rsa)
password_hash_escaped=$(echo -n "$password_hash" | jq -Rsa)
username_escaped=$(echo -n "$username" | jq -Rsa)

cat <<-_EOF_ >user_credentials.json
{
    "encryption_password": $password_escaped,
    "root_enc_password": $password_hash_escaped,
    "users": [
        {
            "enc_password": $password_hash_escaped,
            "groups": [],
            "sudo": true,
            "username": $username_escaped
        }
    ]
}
_EOF_

# Setup partition layout
debug_log "Calculating partition layout for disk: $disk"
disk_size=$(lsblk -bdno SIZE "$disk")
debug_log "Disk size: $disk_size bytes"
mib=$((1024 * 1024))
gib=$((mib * 1024))
disk_size_in_mib=$((disk_size / mib * mib)) # Rounds to nearest MiB

gpt_backup_reserve=$((mib))
boot_partition_start=$((mib))
boot_partition_size=$((2 * gib))

main_partition_start=$((boot_partition_size + boot_partition_start))
main_partition_size=$((disk_size_in_mib - main_partition_start - gpt_backup_reserve))

debug_log "Boot partition: ${boot_partition_size} bytes, Main partition: ${main_partition_size} bytes"

# Detect T2 Mac and set appropriate kernel
if lspci -nn 2>/dev/null | grep -q "106b:180[12]"; then
  kernel_choice="linux-t2"
  debug_log "Detected T2 Mac, using linux-t2 kernel"
else
  kernel_choice="linux"
  debug_log "Using standard linux kernel"
fi

cat <<-_EOF_ >user_configuration.json
{
    "app_config": null,
    "archinstall-language": "English",
    "auth_config": {},
    "audio_config": { "audio": "pipewire" },
    "bootloader": "Limine",
    "custom_commands": [],
    "disk_config": {
        "btrfs_options": { 
          "snapshot_config": {
            "type": "Snapper"
          }
        },
        "config_type": "default_layout",
        "device_modifications": [
            {
                "device": "$disk",
                "partitions": [
                    {
                        "btrfs": [],
                        "dev_path": null,
                        "flags": [ "boot", "esp" ],
                        "fs_type": "fat32",
                        "mount_options": [],
                        "mountpoint": "/boot",
                        "obj_id": "ea21d3f2-82bb-49cc-ab5d-6f81ae94e18d",
                        "size": {
                            "sector_size": { "unit": "B", "value": 512 },
                            "unit": "B",
                            "value": $boot_partition_size
                        },
                        "start": {
                            "sector_size": { "unit": "B", "value": 512 },
                            "unit": "B",
                            "value": $boot_partition_start
                        },
                        "status": "create",
                        "type": "primary"
                    },
                    {
                        "btrfs": [
                            { "mountpoint": "/", "name": "@" },
                            { "mountpoint": "/home", "name": "@home" },
                            { "mountpoint": "/var/log", "name": "@log" },
                            { "mountpoint": "/var/cache/pacman/pkg", "name": "@pkg" }
                        ],
                        "dev_path": null,
                        "flags": [],
                        "fs_type": "btrfs",
                        "mount_options": [ "compress=zstd" ],
                        "mountpoint": null,
                        "obj_id": "8c2c2b92-1070-455d-b76a-56263bab24aa",
                        "size": {
                            "sector_size": { "unit": "B", "value": 512 },
                            "unit": "B",
                            "value": $main_partition_size
                        },
                        "start": {
                            "sector_size": { "unit": "B", "value": 512 },
                            "unit": "B",
                            "value": $main_partition_start
                        },
                        "status": "create",
                        "type": "primary"
                    }
                ],
                "wipe": true
            }
        ],
        "disk_encryption": {
            "encryption_type": "luks",
            "lvm_volumes": [],
            "iter_time": 2000,
            "partitions": [ "8c2c2b92-1070-455d-b76a-56263bab24aa" ],
            "encryption_password": $password_escaped
        }
    },
    "hostname": "$hostname",
    "kernels": [ "$kernel_choice" ],
    "network_config": { "type": "iso" },
    "ntp": true,
    "parallel_downloads": 8,
    "script": null,
    "services": [],
    "swap": true,
    "timezone": "$timezone",
    "locale_config": {
        "kb_layout": "$keyboard",
        "sys_enc": "UTF-8",
        "sys_lang": "en_US.UTF-8"
    },
    "mirror_config": {
        "custom_repositories": [],
        "custom_servers": [
            {"url": "https://mirror.omarchy.org/\$repo/os/\$arch"},
            {"url": "https://mirror.rackspace.com/archlinux/\$repo/os/\$arch"},
            {"url": "https://geo.mirror.pkgbuild.com/\$repo/os/\$arch"}
        ],
        "mirror_regions": {},
        "optional_repositories": []
    },
    "packages": [
        "base-devel",
        "git"
    ],
    "profile_config": {
        "gfx_driver": null,
        "greeter": null,
        "profile": {}
    },
    "version": "3.0.9"
}
_EOF_

log "Created user_configuration.json and user_credentials.json"
log "Configuration complete!"

if [[ $1 == "dry" ]]; then
  echo -e "User Configuration:"
  cat user_configuration.json

  echo -e "\n\nUser Credentials:"
  cat user_credentials.json

  echo -e "\n\nUser Full Name:"
  cat user_full_name.txt

  echo -e "\nUser Email Address:"
  cat user_email_address.txt

  rm user_configuration.json user_credentials.json user_full_name.txt user_email_address.txt
fi
